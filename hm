#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Std;

my @marks = ('', '.'x(int(rand(3))+1), '!');
my %options;
my $char;
my $end;

sub parse($) {
	my $word = shift;
	$char = substr($word, 0, -1);
	$end = substr($word, -1, 1);
}

getopts('ugr', \%options);

if ($options{u}) {
	push(@marks, 'â€¦');
}
if ($options{g}) {
	$char = 'gr';
} elsif ($options{r}) {
	$char = 'hr';
} elsif (@ARGV) {
	parse(shift);
} else {
	parse((split(/\//, $0))[-1]);
}
print(($char.$end x(int(rand(4))+1))x(int(rand(12)/10)+1).$marks[rand@marks]."\n")

__END__

=head1 NAME

hm - say hm

=head1 SYNOPSIS

B<hm> [ B<-u> ] [ B<-g>|B<-r>|I<string> ]

=head1 DESCRIPTION

B<hm> says 'hm' in a variety of ways, such as 'hmm...', 'hm!' or 'hmmhmm'.

It does that by taking a string, repeating its last character several times,
maybe doing all that again, and appending some punctuation to the end.

=head1 OPTIONS

=over

=item B<-u>

Use the unicode variant of '...'.

=item B<-g>

Use 'grm' as the string.

=item B<-r>

Use 'hrm' as the string.

=item I<string>

Use I<string> as the string.

=back

When no arguments are given, the program name is used as the string.

=head1 AUTHOR

Daniel Friesel <derf@derf.homelinux.org>

L<https://derf.homelinux.org/~derf/code/hm>

=head1 LICENSE

  0. You just DO WHAT THE FUCK YOU WANT TO.
